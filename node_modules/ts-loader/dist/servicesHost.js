"use strict";
var typescript = require('typescript');
var constants = require('./constants');
var path = require('path');
var makeResolver = require('./resolver');
var utils = require('./utils');
/**
 * Create the TypeScript language service
 */
function makeServicesHost(scriptRegex, log, loader, instance, appendTsSuffixTo) {
    var compiler = instance.compiler, compilerOptions = instance.compilerOptions, files = instance.files;
    var newLine = compilerOptions.newLine === 0 /* CarriageReturnLineFeed */ ? constants.CarriageReturnLineFeed :
        compilerOptions.newLine === 1 /* LineFeed */ ? constants.LineFeed :
            constants.EOL;
    // make a (sync) resolver that follows webpack's rules
    var resolver = makeResolver(loader.options);
    var moduleResolutionHost = {
        fileExists: function (fileName) { return utils.readFile(fileName) !== undefined; },
        readFile: function (fileName) { return utils.readFile(fileName); }
    };
    return {
        getProjectVersion: function () { return ("" + instance.version); },
        getScriptFileNames: function () { return Object.keys(files).filter(function (filePath) { return scriptRegex.test(filePath); }); },
        getScriptVersion: function (fileName) {
            fileName = path.normalize(fileName);
            return files[fileName] && files[fileName].version.toString();
        },
        getScriptSnapshot: function (fileName) {
            // This is called any time TypeScript needs a file's text
            // We either load from memory or from disk
            fileName = path.normalize(fileName);
            var file = files[fileName];
            if (!file) {
                var text = utils.readFile(fileName);
                if (!text) {
                    return undefined;
                }
                file = files[fileName] = { version: 0, text: text };
            }
            return compiler.ScriptSnapshot.fromString(file.text);
        },
        /**
         * getDirectories is also required for full import and type reference completions.
         * Without it defined, certain completions will not be provided
         */
        getDirectories: typescript.sys ? typescript.sys.getDirectories : undefined,
        /**
         * For @types expansion, these two functions are needed.
         */
        directoryExists: typescript.sys ? typescript.sys.directoryExists : undefined,
        getCurrentDirectory: function () { return process.cwd(); },
        getCompilationSettings: function () { return compilerOptions; },
        getDefaultLibFileName: function (options) { return compiler.getDefaultLibFilePath(options); },
        getNewLine: function () { return newLine; },
        log: log.log,
        resolveModuleNames: function (moduleNames, containingFile) {
            var resolvedModules = [];
            for (var _i = 0, moduleNames_1 = moduleNames; _i < moduleNames_1.length; _i++) {
                var moduleName = moduleNames_1[_i];
                var resolvedFileName = void 0;
                var resolutionResult = void 0;
                try {
                    resolvedFileName = resolver.resolveSync(path.normalize(path.dirname(containingFile)), moduleName);
                    resolvedFileName = utils.appendTsSuffixIfMatch(appendTsSuffixTo, resolvedFileName);
                    if (!resolvedFileName.match(scriptRegex)) {
                        resolvedFileName = null;
                    }
                    else {
                        resolutionResult = { resolvedFileName: resolvedFileName };
                    }
                }
                catch (e) {
                    resolvedFileName = null;
                }
                var tsResolution = compiler.resolveModuleName(moduleName, containingFile, compilerOptions, moduleResolutionHost);
                if (tsResolution.resolvedModule) {
                    if (resolvedFileName) {
                        if (resolvedFileName === tsResolution.resolvedModule.resolvedFileName) {
                            resolutionResult.isExternalLibraryImport = tsResolution.resolvedModule.isExternalLibraryImport;
                        }
                    }
                    else {
                        resolutionResult = tsResolution.resolvedModule;
                    }
                }
                resolvedModules.push(resolutionResult);
            }
            var importedFiles = resolvedModules
                .filter(function (m) { return m !== null && m !== undefined; })
                .map(function (m) { return m.resolvedFileName; });
            instance.dependencyGraph[path.normalize(containingFile)] = importedFiles;
            importedFiles.forEach(function (importedFileName) {
                if (!instance.reverseDependencyGraph[importedFileName]) {
                    instance.reverseDependencyGraph[importedFileName] = {};
                }
                instance.reverseDependencyGraph[importedFileName][path.normalize(containingFile)] = true;
            });
            return resolvedModules;
        }
    };
}
module.exports = makeServicesHost;
